{"ast":null,"code":"import React, { forwardRef, useState, useRef, useId, useImperativeHandle, useCallback, useEffect, Children } from 'react';\nimport { findFirstFocusableNodeIncludingDisabled, focusNextFocusableNode } from '../../utilities/focus.js';\nimport { portal } from '../shared.js';\nimport { setActivatorAttributes } from './set-activator-attributes.js';\nimport { PopoverCloseSource, PopoverOverlay } from './components/PopoverOverlay/PopoverOverlay.js';\nimport { Pane } from './components/Pane/Pane.js';\nimport { Section } from './components/Section/Section.js';\nimport { Portal } from '../Portal/Portal.js';\n\n// TypeScript can't generate types that correctly infer the typing of\n// subcomponents so explicitly state the subcomponents in the type definition.\n// Letting this be implicit works in this project but fails in projects that use\n// generated *.d.ts files.\n\nconst PopoverComponent = /*#__PURE__*/forwardRef(function Popover({\n  activatorWrapper = 'div',\n  children,\n  onClose,\n  activator,\n  preventFocusOnClose,\n  active,\n  fixed,\n  ariaHaspopup,\n  preferInputActivator = true,\n  zIndexOverride,\n  ...rest\n}, ref) {\n  const [isDisplayed, setIsDisplay] = useState(false);\n  const [activatorNode, setActivatorNode] = useState();\n  const overlayRef = useRef(null);\n  const activatorContainer = useRef(null);\n  const WrapperComponent = activatorWrapper;\n  const id = useId();\n  function forceUpdatePosition() {\n    overlayRef.current?.forceUpdatePosition();\n  }\n  const handleClose = source => {\n    onClose(source);\n    if (activatorContainer.current == null || preventFocusOnClose) {\n      return;\n    }\n    if (source === PopoverCloseSource.FocusOut && activatorNode) {\n      const focusableActivator = findFirstFocusableNodeIncludingDisabled(activatorNode) || findFirstFocusableNodeIncludingDisabled(activatorContainer.current) || activatorContainer.current;\n      if (!focusNextFocusableNode(focusableActivator, isInPortal)) {\n        focusableActivator.focus();\n      }\n    } else if (source === PopoverCloseSource.EscapeKeypress && activatorNode) {\n      const focusableActivator = findFirstFocusableNodeIncludingDisabled(activatorNode) || findFirstFocusableNodeIncludingDisabled(activatorContainer.current) || activatorContainer.current;\n      if (focusableActivator) {\n        focusableActivator.focus();\n      } else {\n        focusNextFocusableNode(focusableActivator, isInPortal);\n      }\n    }\n  };\n  useImperativeHandle(ref, () => {\n    return {\n      forceUpdatePosition,\n      close: (target = 'activator') => {\n        const source = target === 'activator' ? PopoverCloseSource.EscapeKeypress : PopoverCloseSource.FocusOut;\n        handleClose(source);\n      }\n    };\n  });\n  const setAccessibilityAttributes = useCallback(() => {\n    if (activatorContainer.current == null) {\n      return;\n    }\n    const firstFocusable = findFirstFocusableNodeIncludingDisabled(activatorContainer.current);\n    const focusableActivator = firstFocusable || activatorContainer.current;\n    const activatorDisabled = 'disabled' in focusableActivator && Boolean(focusableActivator.disabled);\n    setActivatorAttributes(focusableActivator, {\n      id,\n      active,\n      ariaHaspopup,\n      activatorDisabled\n    });\n  }, [id, active, ariaHaspopup]);\n  useEffect(() => {\n    function setDisplayState() {\n      /**\n       * This is a workaround to prevent rendering the Popover when the content is moved into\n       * a React portal that hasn't been rendered. We don't want to render the Popover in this\n       * case because the auto-focus logic will break. We wait until the activatorContainer is\n       * displayed, which is when it has an offsetParent, or if the activatorContainer is the\n       * body, if it has a clientWidth bigger than 0.\n       * See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent\n       */\n\n      setIsDisplay(Boolean(activatorContainer.current && (activatorContainer.current.offsetParent !== null || activatorContainer.current === activatorContainer.current.ownerDocument.body && activatorContainer.current.clientWidth > 0)));\n    }\n    if (!activatorContainer.current) {\n      return;\n    }\n    const observer = new ResizeObserver(setDisplayState);\n    observer.observe(activatorContainer.current);\n    setDisplayState();\n    return () => {\n      observer.disconnect();\n    };\n  }, []);\n  useEffect(() => {\n    if (!activatorNode && activatorContainer.current) {\n      setActivatorNode(activatorContainer.current.firstElementChild);\n    } else if (activatorNode && activatorContainer.current && !activatorContainer.current.contains(activatorNode)) {\n      setActivatorNode(activatorContainer.current.firstElementChild);\n    }\n    setAccessibilityAttributes();\n  }, [activatorNode, setAccessibilityAttributes]);\n  useEffect(() => {\n    if (activatorNode && activatorContainer.current) {\n      setActivatorNode(activatorContainer.current.firstElementChild);\n    }\n    setAccessibilityAttributes();\n  }, [activatorNode, setAccessibilityAttributes]);\n  const portal = activatorNode && isDisplayed ? /*#__PURE__*/React.createElement(Portal, {\n    idPrefix: \"popover\"\n  }, /*#__PURE__*/React.createElement(PopoverOverlay, Object.assign({\n    ref: overlayRef,\n    id: id,\n    activator: activatorNode,\n    preferInputActivator: preferInputActivator,\n    onClose: handleClose,\n    active: active,\n    fixed: fixed,\n    zIndexOverride: zIndexOverride\n  }, rest), children)) : null;\n  return /*#__PURE__*/React.createElement(WrapperComponent, {\n    ref: activatorContainer\n  }, Children.only(activator), portal);\n});\nfunction isInPortal(element) {\n  let parentElement = element.parentElement;\n  while (parentElement) {\n    if (parentElement.matches(portal.selector)) return false;\n    parentElement = parentElement.parentElement;\n  }\n  return true;\n}\nconst Popover = Object.assign(PopoverComponent, {\n  Pane,\n  Section\n});\nexport { Popover, PopoverCloseSource };","map":{"version":3,"names":["React","forwardRef","useState","useRef","useId","useImperativeHandle","useCallback","useEffect","Children","findFirstFocusableNodeIncludingDisabled","focusNextFocusableNode","portal","setActivatorAttributes","PopoverCloseSource","PopoverOverlay","Pane","Section","Portal","PopoverComponent","Popover","activatorWrapper","children","onClose","activator","preventFocusOnClose","active","fixed","ariaHaspopup","preferInputActivator","zIndexOverride","rest","ref","isDisplayed","setIsDisplay","activatorNode","setActivatorNode","overlayRef","activatorContainer","WrapperComponent","id","forceUpdatePosition","current","handleClose","source","FocusOut","focusableActivator","isInPortal","focus","EscapeKeypress","close","target","setAccessibilityAttributes","firstFocusable","activatorDisabled","Boolean","disabled","setDisplayState","offsetParent","ownerDocument","body","clientWidth","observer","ResizeObserver","observe","disconnect","firstElementChild","contains","createElement","idPrefix","Object","assign","only","element","parentElement","matches","selector"],"sources":["/Users/shannondutton/Documents/Code Projects/ProductCreator/node_modules/@shopify/polaris/build/esm/components/Popover/Popover.js"],"sourcesContent":["import React, { forwardRef, useState, useRef, useId, useImperativeHandle, useCallback, useEffect, Children } from 'react';\nimport { findFirstFocusableNodeIncludingDisabled, focusNextFocusableNode } from '../../utilities/focus.js';\nimport { portal } from '../shared.js';\nimport { setActivatorAttributes } from './set-activator-attributes.js';\nimport { PopoverCloseSource, PopoverOverlay } from './components/PopoverOverlay/PopoverOverlay.js';\nimport { Pane } from './components/Pane/Pane.js';\nimport { Section } from './components/Section/Section.js';\nimport { Portal } from '../Portal/Portal.js';\n\n// TypeScript can't generate types that correctly infer the typing of\n// subcomponents so explicitly state the subcomponents in the type definition.\n// Letting this be implicit works in this project but fails in projects that use\n// generated *.d.ts files.\n\nconst PopoverComponent = /*#__PURE__*/forwardRef(function Popover({\n  activatorWrapper = 'div',\n  children,\n  onClose,\n  activator,\n  preventFocusOnClose,\n  active,\n  fixed,\n  ariaHaspopup,\n  preferInputActivator = true,\n  zIndexOverride,\n  ...rest\n}, ref) {\n  const [isDisplayed, setIsDisplay] = useState(false);\n  const [activatorNode, setActivatorNode] = useState();\n  const overlayRef = useRef(null);\n  const activatorContainer = useRef(null);\n  const WrapperComponent = activatorWrapper;\n  const id = useId();\n  function forceUpdatePosition() {\n    overlayRef.current?.forceUpdatePosition();\n  }\n  const handleClose = source => {\n    onClose(source);\n    if (activatorContainer.current == null || preventFocusOnClose) {\n      return;\n    }\n    if (source === PopoverCloseSource.FocusOut && activatorNode) {\n      const focusableActivator = findFirstFocusableNodeIncludingDisabled(activatorNode) || findFirstFocusableNodeIncludingDisabled(activatorContainer.current) || activatorContainer.current;\n      if (!focusNextFocusableNode(focusableActivator, isInPortal)) {\n        focusableActivator.focus();\n      }\n    } else if (source === PopoverCloseSource.EscapeKeypress && activatorNode) {\n      const focusableActivator = findFirstFocusableNodeIncludingDisabled(activatorNode) || findFirstFocusableNodeIncludingDisabled(activatorContainer.current) || activatorContainer.current;\n      if (focusableActivator) {\n        focusableActivator.focus();\n      } else {\n        focusNextFocusableNode(focusableActivator, isInPortal);\n      }\n    }\n  };\n  useImperativeHandle(ref, () => {\n    return {\n      forceUpdatePosition,\n      close: (target = 'activator') => {\n        const source = target === 'activator' ? PopoverCloseSource.EscapeKeypress : PopoverCloseSource.FocusOut;\n        handleClose(source);\n      }\n    };\n  });\n  const setAccessibilityAttributes = useCallback(() => {\n    if (activatorContainer.current == null) {\n      return;\n    }\n    const firstFocusable = findFirstFocusableNodeIncludingDisabled(activatorContainer.current);\n    const focusableActivator = firstFocusable || activatorContainer.current;\n    const activatorDisabled = 'disabled' in focusableActivator && Boolean(focusableActivator.disabled);\n    setActivatorAttributes(focusableActivator, {\n      id,\n      active,\n      ariaHaspopup,\n      activatorDisabled\n    });\n  }, [id, active, ariaHaspopup]);\n  useEffect(() => {\n    function setDisplayState() {\n      /**\n       * This is a workaround to prevent rendering the Popover when the content is moved into\n       * a React portal that hasn't been rendered. We don't want to render the Popover in this\n       * case because the auto-focus logic will break. We wait until the activatorContainer is\n       * displayed, which is when it has an offsetParent, or if the activatorContainer is the\n       * body, if it has a clientWidth bigger than 0.\n       * See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent\n       */\n\n      setIsDisplay(Boolean(activatorContainer.current && (activatorContainer.current.offsetParent !== null || activatorContainer.current === activatorContainer.current.ownerDocument.body && activatorContainer.current.clientWidth > 0)));\n    }\n    if (!activatorContainer.current) {\n      return;\n    }\n    const observer = new ResizeObserver(setDisplayState);\n    observer.observe(activatorContainer.current);\n    setDisplayState();\n    return () => {\n      observer.disconnect();\n    };\n  }, []);\n  useEffect(() => {\n    if (!activatorNode && activatorContainer.current) {\n      setActivatorNode(activatorContainer.current.firstElementChild);\n    } else if (activatorNode && activatorContainer.current && !activatorContainer.current.contains(activatorNode)) {\n      setActivatorNode(activatorContainer.current.firstElementChild);\n    }\n    setAccessibilityAttributes();\n  }, [activatorNode, setAccessibilityAttributes]);\n  useEffect(() => {\n    if (activatorNode && activatorContainer.current) {\n      setActivatorNode(activatorContainer.current.firstElementChild);\n    }\n    setAccessibilityAttributes();\n  }, [activatorNode, setAccessibilityAttributes]);\n  const portal = activatorNode && isDisplayed ? /*#__PURE__*/React.createElement(Portal, {\n    idPrefix: \"popover\"\n  }, /*#__PURE__*/React.createElement(PopoverOverlay, Object.assign({\n    ref: overlayRef,\n    id: id,\n    activator: activatorNode,\n    preferInputActivator: preferInputActivator,\n    onClose: handleClose,\n    active: active,\n    fixed: fixed,\n    zIndexOverride: zIndexOverride\n  }, rest), children)) : null;\n  return /*#__PURE__*/React.createElement(WrapperComponent, {\n    ref: activatorContainer\n  }, Children.only(activator), portal);\n});\nfunction isInPortal(element) {\n  let parentElement = element.parentElement;\n  while (parentElement) {\n    if (parentElement.matches(portal.selector)) return false;\n    parentElement = parentElement.parentElement;\n  }\n  return true;\n}\nconst Popover = Object.assign(PopoverComponent, {\n  Pane,\n  Section\n});\n\nexport { Popover, PopoverCloseSource };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}