{"ast":null,"code":"import { themeDefault } from '@shopify/polaris-tokens';\nimport { debounce } from '../debounce.js';\nimport { scrollable, dataPolarisTopBar } from '../../components/shared.js';\nimport { stackedContent } from '../breakpoints.js';\nimport { getRectForNode } from '../geometry.js';\nconst SIXTY_FPS = 1000 / 60;\nclass StickyManager {\n  constructor(container) {\n    this.stickyItems = [];\n    this.stuckItems = [];\n    this.container = null;\n    this.topBarOffset = 0;\n    this.handleResize = debounce(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n    this.handleScroll = debounce(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n    if (container) {\n      this.setContainer(container);\n    }\n  }\n  registerStickyItem(stickyItem) {\n    this.stickyItems.push(stickyItem);\n  }\n  unregisterStickyItem(nodeToRemove) {\n    const nodeIndex = this.stickyItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stickyItems.splice(nodeIndex, 1);\n  }\n  getStickyItem(node) {\n    return this.stickyItems.find(({\n      stickyNode\n    }) => node === stickyNode);\n  }\n  setContainer(el) {\n    this.container = el;\n    if (isDocument(el)) {\n      this.setTopBarOffset(el);\n    }\n    this.container.addEventListener('scroll', this.handleScroll);\n    window.addEventListener('resize', this.handleResize);\n    this.manageStickyItems();\n  }\n  removeScrollListener() {\n    if (this.container) {\n      this.container.removeEventListener('scroll', this.handleScroll);\n      window.removeEventListener('resize', this.handleResize);\n    }\n  }\n  manageStickyItems() {\n    if (this.stickyItems.length <= 0) {\n      return;\n    }\n    const scrollTop = this.container ? scrollTopFor(this.container) : 0;\n    const containerTop = getRectForNode(this.container).top + this.topBarOffset;\n    this.stickyItems.forEach(stickyItem => {\n      const {\n        handlePositioning\n      } = stickyItem;\n      const {\n        sticky,\n        top,\n        left,\n        width\n      } = this.evaluateStickyItem(stickyItem, scrollTop, containerTop);\n      this.updateStuckItems(stickyItem, sticky);\n      handlePositioning(sticky, top, left, width);\n    });\n  }\n  evaluateStickyItem(stickyItem, scrollTop, containerTop) {\n    const {\n      stickyNode,\n      placeHolderNode,\n      boundingElement,\n      offset,\n      disableWhenStacked\n    } = stickyItem;\n    if (disableWhenStacked && stackedContent().matches) {\n      return {\n        sticky: false,\n        top: 0,\n        left: 0,\n        width: 'auto'\n      };\n    }\n    const stickyOffset = offset ? this.getOffset(stickyNode) + parseInt(\n    // Important: This will not update when the active theme changes.\n    // Update this to `useTheme` once converted to a function component.\n    themeDefault.space['space-500'], 10) : this.getOffset(stickyNode);\n    const scrollPosition = scrollTop + stickyOffset;\n    const placeHolderNodeCurrentTop = placeHolderNode.getBoundingClientRect().top - containerTop + scrollTop;\n    const top = containerTop + stickyOffset;\n    const width = placeHolderNode.getBoundingClientRect().width;\n    const left = placeHolderNode.getBoundingClientRect().left;\n    let sticky;\n    if (boundingElement == null) {\n      sticky = scrollPosition >= placeHolderNodeCurrentTop;\n    } else {\n      const stickyItemHeight = stickyNode.getBoundingClientRect().height || stickyNode.firstElementChild?.getBoundingClientRect().height || 0;\n      const stickyItemBottomPosition = boundingElement.getBoundingClientRect().bottom - stickyItemHeight + scrollTop - containerTop;\n      sticky = scrollPosition >= placeHolderNodeCurrentTop && scrollPosition < stickyItemBottomPosition;\n    }\n    return {\n      sticky,\n      top,\n      left,\n      width\n    };\n  }\n  updateStuckItems(item, sticky) {\n    const {\n      stickyNode\n    } = item;\n    if (sticky && !this.isNodeStuck(stickyNode)) {\n      this.addStuckItem(item);\n    } else if (!sticky && this.isNodeStuck(stickyNode)) {\n      this.removeStuckItem(item);\n    }\n  }\n  addStuckItem(stickyItem) {\n    this.stuckItems.push(stickyItem);\n  }\n  removeStuckItem(stickyItem) {\n    const {\n      stickyNode: nodeToRemove\n    } = stickyItem;\n    const nodeIndex = this.stuckItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stuckItems.splice(nodeIndex, 1);\n  }\n  getOffset(node) {\n    if (this.stuckItems.length === 0) {\n      return 0;\n    }\n    let offset = 0;\n    let count = 0;\n    const stuckNodesLength = this.stuckItems.length;\n    const nodeRect = getRectForNode(node);\n    while (count < stuckNodesLength) {\n      const stuckNode = this.stuckItems[count].stickyNode;\n      if (stuckNode !== node) {\n        const stuckNodeRect = getRectForNode(stuckNode);\n        if (!horizontallyOverlaps(nodeRect, stuckNodeRect)) {\n          offset += getRectForNode(stuckNode).height;\n        }\n      } else {\n        break;\n      }\n      count++;\n    }\n    return offset;\n  }\n  isNodeStuck(node) {\n    const nodeFound = this.stuckItems.findIndex(({\n      stickyNode\n    }) => node === stickyNode);\n    return nodeFound >= 0;\n  }\n  setTopBarOffset(container) {\n    const topbarElement = container.querySelector(`:not(${scrollable.selector}) ${dataPolarisTopBar.selector}`);\n    this.topBarOffset = topbarElement ? topbarElement.clientHeight : 0;\n  }\n}\nfunction isDocument(node) {\n  return node === document;\n}\nfunction scrollTopFor(container) {\n  return isDocument(container) ? document.body.scrollTop || document.documentElement.scrollTop : container.scrollTop;\n}\nfunction horizontallyOverlaps(rect1, rect2) {\n  const rect1Left = rect1.left;\n  const rect1Right = rect1.left + rect1.width;\n  const rect2Left = rect2.left;\n  const rect2Right = rect2.left + rect2.width;\n  return rect2Right < rect1Left || rect1Right < rect2Left;\n}\nexport { StickyManager };","map":{"version":3,"names":["themeDefault","debounce","scrollable","dataPolarisTopBar","stackedContent","getRectForNode","SIXTY_FPS","StickyManager","constructor","container","stickyItems","stuckItems","topBarOffset","handleResize","manageStickyItems","leading","trailing","maxWait","handleScroll","setContainer","registerStickyItem","stickyItem","push","unregisterStickyItem","nodeToRemove","nodeIndex","findIndex","stickyNode","splice","getStickyItem","node","find","el","isDocument","setTopBarOffset","addEventListener","window","removeScrollListener","removeEventListener","length","scrollTop","scrollTopFor","containerTop","top","forEach","handlePositioning","sticky","left","width","evaluateStickyItem","updateStuckItems","placeHolderNode","boundingElement","offset","disableWhenStacked","matches","stickyOffset","getOffset","parseInt","space","scrollPosition","placeHolderNodeCurrentTop","getBoundingClientRect","stickyItemHeight","height","firstElementChild","stickyItemBottomPosition","bottom","item","isNodeStuck","addStuckItem","removeStuckItem","count","stuckNodesLength","nodeRect","stuckNode","stuckNodeRect","horizontallyOverlaps","nodeFound","topbarElement","querySelector","selector","clientHeight","document","body","documentElement","rect1","rect2","rect1Left","rect1Right","rect2Left","rect2Right"],"sources":["/Users/shannondutton/Documents/Code Projects/ProductCreator/node_modules/@shopify/polaris/build/esm/utilities/sticky-manager/sticky-manager.js"],"sourcesContent":["import { themeDefault } from '@shopify/polaris-tokens';\nimport { debounce } from '../debounce.js';\nimport { scrollable, dataPolarisTopBar } from '../../components/shared.js';\nimport { stackedContent } from '../breakpoints.js';\nimport { getRectForNode } from '../geometry.js';\n\nconst SIXTY_FPS = 1000 / 60;\nclass StickyManager {\n  constructor(container) {\n    this.stickyItems = [];\n    this.stuckItems = [];\n    this.container = null;\n    this.topBarOffset = 0;\n    this.handleResize = debounce(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n    this.handleScroll = debounce(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n    if (container) {\n      this.setContainer(container);\n    }\n  }\n  registerStickyItem(stickyItem) {\n    this.stickyItems.push(stickyItem);\n  }\n  unregisterStickyItem(nodeToRemove) {\n    const nodeIndex = this.stickyItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stickyItems.splice(nodeIndex, 1);\n  }\n  getStickyItem(node) {\n    return this.stickyItems.find(({\n      stickyNode\n    }) => node === stickyNode);\n  }\n  setContainer(el) {\n    this.container = el;\n    if (isDocument(el)) {\n      this.setTopBarOffset(el);\n    }\n    this.container.addEventListener('scroll', this.handleScroll);\n    window.addEventListener('resize', this.handleResize);\n    this.manageStickyItems();\n  }\n  removeScrollListener() {\n    if (this.container) {\n      this.container.removeEventListener('scroll', this.handleScroll);\n      window.removeEventListener('resize', this.handleResize);\n    }\n  }\n  manageStickyItems() {\n    if (this.stickyItems.length <= 0) {\n      return;\n    }\n    const scrollTop = this.container ? scrollTopFor(this.container) : 0;\n    const containerTop = getRectForNode(this.container).top + this.topBarOffset;\n    this.stickyItems.forEach(stickyItem => {\n      const {\n        handlePositioning\n      } = stickyItem;\n      const {\n        sticky,\n        top,\n        left,\n        width\n      } = this.evaluateStickyItem(stickyItem, scrollTop, containerTop);\n      this.updateStuckItems(stickyItem, sticky);\n      handlePositioning(sticky, top, left, width);\n    });\n  }\n  evaluateStickyItem(stickyItem, scrollTop, containerTop) {\n    const {\n      stickyNode,\n      placeHolderNode,\n      boundingElement,\n      offset,\n      disableWhenStacked\n    } = stickyItem;\n    if (disableWhenStacked && stackedContent().matches) {\n      return {\n        sticky: false,\n        top: 0,\n        left: 0,\n        width: 'auto'\n      };\n    }\n    const stickyOffset = offset ? this.getOffset(stickyNode) + parseInt(\n    // Important: This will not update when the active theme changes.\n    // Update this to `useTheme` once converted to a function component.\n    themeDefault.space['space-500'], 10) : this.getOffset(stickyNode);\n    const scrollPosition = scrollTop + stickyOffset;\n    const placeHolderNodeCurrentTop = placeHolderNode.getBoundingClientRect().top - containerTop + scrollTop;\n    const top = containerTop + stickyOffset;\n    const width = placeHolderNode.getBoundingClientRect().width;\n    const left = placeHolderNode.getBoundingClientRect().left;\n    let sticky;\n    if (boundingElement == null) {\n      sticky = scrollPosition >= placeHolderNodeCurrentTop;\n    } else {\n      const stickyItemHeight = stickyNode.getBoundingClientRect().height || stickyNode.firstElementChild?.getBoundingClientRect().height || 0;\n      const stickyItemBottomPosition = boundingElement.getBoundingClientRect().bottom - stickyItemHeight + scrollTop - containerTop;\n      sticky = scrollPosition >= placeHolderNodeCurrentTop && scrollPosition < stickyItemBottomPosition;\n    }\n    return {\n      sticky,\n      top,\n      left,\n      width\n    };\n  }\n  updateStuckItems(item, sticky) {\n    const {\n      stickyNode\n    } = item;\n    if (sticky && !this.isNodeStuck(stickyNode)) {\n      this.addStuckItem(item);\n    } else if (!sticky && this.isNodeStuck(stickyNode)) {\n      this.removeStuckItem(item);\n    }\n  }\n  addStuckItem(stickyItem) {\n    this.stuckItems.push(stickyItem);\n  }\n  removeStuckItem(stickyItem) {\n    const {\n      stickyNode: nodeToRemove\n    } = stickyItem;\n    const nodeIndex = this.stuckItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stuckItems.splice(nodeIndex, 1);\n  }\n  getOffset(node) {\n    if (this.stuckItems.length === 0) {\n      return 0;\n    }\n    let offset = 0;\n    let count = 0;\n    const stuckNodesLength = this.stuckItems.length;\n    const nodeRect = getRectForNode(node);\n    while (count < stuckNodesLength) {\n      const stuckNode = this.stuckItems[count].stickyNode;\n      if (stuckNode !== node) {\n        const stuckNodeRect = getRectForNode(stuckNode);\n        if (!horizontallyOverlaps(nodeRect, stuckNodeRect)) {\n          offset += getRectForNode(stuckNode).height;\n        }\n      } else {\n        break;\n      }\n      count++;\n    }\n    return offset;\n  }\n  isNodeStuck(node) {\n    const nodeFound = this.stuckItems.findIndex(({\n      stickyNode\n    }) => node === stickyNode);\n    return nodeFound >= 0;\n  }\n  setTopBarOffset(container) {\n    const topbarElement = container.querySelector(`:not(${scrollable.selector}) ${dataPolarisTopBar.selector}`);\n    this.topBarOffset = topbarElement ? topbarElement.clientHeight : 0;\n  }\n}\nfunction isDocument(node) {\n  return node === document;\n}\nfunction scrollTopFor(container) {\n  return isDocument(container) ? document.body.scrollTop || document.documentElement.scrollTop : container.scrollTop;\n}\nfunction horizontallyOverlaps(rect1, rect2) {\n  const rect1Left = rect1.left;\n  const rect1Right = rect1.left + rect1.width;\n  const rect2Left = rect2.left;\n  const rect2Right = rect2.left + rect2.width;\n  return rect2Right < rect1Left || rect1Right < rect2Left;\n}\n\nexport { StickyManager };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}