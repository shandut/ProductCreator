{"ast":null,"code":"import { Rect } from '../../../utilities/geometry.js';\nfunction calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition, fixed, topBarOffset = 0) {\n  const activatorTop = activatorRect.top;\n  const activatorBottom = activatorTop + activatorRect.height;\n  const spaceAbove = activatorRect.top - topBarOffset;\n  const spaceBelow = containerRect.height - activatorRect.top - activatorRect.height;\n  const desiredHeight = overlayRect.height;\n  const verticalMargins = overlayMargins.activator + overlayMargins.container;\n  const minimumSpaceToScroll = overlayMargins.container;\n  const distanceToTopScroll = activatorRect.top - Math.max(scrollableContainerRect.top, 0);\n  const distanceToBottomScroll = containerRect.top + Math.min(containerRect.height, scrollableContainerRect.top + scrollableContainerRect.height) - (activatorRect.top + activatorRect.height);\n  const enoughSpaceFromTopScroll = distanceToTopScroll >= minimumSpaceToScroll;\n  const enoughSpaceFromBottomScroll = distanceToBottomScroll >= minimumSpaceToScroll;\n  const heightIfAbove = Math.min(spaceAbove, desiredHeight);\n  const heightIfBelow = Math.min(spaceBelow, desiredHeight);\n  const heightIfAboveCover = Math.min(spaceAbove + activatorRect.height, desiredHeight);\n  const heightIfBelowCover = Math.min(spaceBelow + activatorRect.height, desiredHeight);\n  const containerRectTop = fixed ? 0 : containerRect.top;\n  const positionIfAbove = {\n    height: heightIfAbove - verticalMargins,\n    top: activatorTop + containerRectTop - heightIfAbove,\n    positioning: 'above'\n  };\n  const positionIfBelow = {\n    height: heightIfBelow - verticalMargins,\n    top: activatorBottom + containerRectTop,\n    positioning: 'below'\n  };\n  const positionIfCoverBelow = {\n    height: heightIfBelowCover - verticalMargins,\n    top: activatorTop + containerRectTop,\n    positioning: 'cover'\n  };\n  const positionIfCoverAbove = {\n    height: heightIfAboveCover - verticalMargins,\n    top: activatorTop + containerRectTop - heightIfAbove + activatorRect.height + verticalMargins,\n    positioning: 'cover'\n  };\n  if (preferredPosition === 'above') {\n    return (enoughSpaceFromTopScroll || distanceToTopScroll >= distanceToBottomScroll && !enoughSpaceFromBottomScroll) && (spaceAbove > desiredHeight || spaceAbove > spaceBelow) ? positionIfAbove : positionIfBelow;\n  }\n  if (preferredPosition === 'below') {\n    return (enoughSpaceFromBottomScroll || distanceToBottomScroll >= distanceToTopScroll && !enoughSpaceFromTopScroll) && (spaceBelow > desiredHeight || spaceBelow > spaceAbove) ? positionIfBelow : positionIfAbove;\n  }\n  if (preferredPosition === 'cover') {\n    return (enoughSpaceFromBottomScroll || distanceToBottomScroll >= distanceToTopScroll && !enoughSpaceFromTopScroll) && (spaceBelow + activatorRect.height > desiredHeight || spaceBelow > spaceAbove) ? positionIfCoverBelow : positionIfCoverAbove;\n  }\n  if (enoughSpaceFromTopScroll && enoughSpaceFromBottomScroll) {\n    return spaceAbove > spaceBelow ? positionIfAbove : positionIfBelow;\n  }\n  return distanceToTopScroll > minimumSpaceToScroll ? positionIfAbove : positionIfBelow;\n}\nfunction calculateHorizontalPosition(activatorRect, overlayRect, containerRect, overlayMargins, preferredAlignment) {\n  const maximum = containerRect.width - overlayRect.width;\n  if (preferredAlignment === 'left') {\n    return Math.min(maximum, Math.max(0, activatorRect.left - overlayMargins.horizontal));\n  } else if (preferredAlignment === 'right') {\n    const activatorRight = containerRect.width - (activatorRect.left + activatorRect.width);\n    return Math.min(maximum, Math.max(0, activatorRight - overlayMargins.horizontal));\n  }\n  return Math.min(maximum, Math.max(0, activatorRect.center.x - overlayRect.width / 2));\n}\nfunction rectIsOutsideOfRect(inner, outer) {\n  const {\n    center\n  } = inner;\n  return center.y < outer.top || center.y > outer.top + outer.height;\n}\nfunction intersectionWithViewport(rect, viewport = windowRect()) {\n  const top = Math.max(rect.top, 0);\n  const left = Math.max(rect.left, 0);\n  const bottom = Math.min(rect.top + rect.height, viewport.height);\n  const right = Math.min(rect.left + rect.width, viewport.width);\n  return new Rect({\n    top,\n    left,\n    height: bottom - top,\n    width: right - left\n  });\n}\nfunction windowRect(node) {\n  const document = node?.ownerDocument || globalThis.document;\n  const window = document.defaultView || globalThis.window;\n  return new Rect({\n    top: window.scrollY,\n    left: window.scrollX,\n    height: window.innerHeight,\n    width: document.body.clientWidth\n  });\n}\nexport { calculateHorizontalPosition, calculateVerticalPosition, intersectionWithViewport, rectIsOutsideOfRect, windowRect };","map":{"version":3,"names":["Rect","calculateVerticalPosition","activatorRect","overlayRect","overlayMargins","scrollableContainerRect","containerRect","preferredPosition","fixed","topBarOffset","activatorTop","top","activatorBottom","height","spaceAbove","spaceBelow","desiredHeight","verticalMargins","activator","container","minimumSpaceToScroll","distanceToTopScroll","Math","max","distanceToBottomScroll","min","enoughSpaceFromTopScroll","enoughSpaceFromBottomScroll","heightIfAbove","heightIfBelow","heightIfAboveCover","heightIfBelowCover","containerRectTop","positionIfAbove","positioning","positionIfBelow","positionIfCoverBelow","positionIfCoverAbove","calculateHorizontalPosition","preferredAlignment","maximum","width","left","horizontal","activatorRight","center","x","rectIsOutsideOfRect","inner","outer","y","intersectionWithViewport","rect","viewport","windowRect","bottom","right","node","document","ownerDocument","globalThis","window","defaultView","scrollY","scrollX","innerHeight","body","clientWidth"],"sources":["/Users/shannondutton/Documents/Code Projects/ProductCreator/node_modules/@shopify/polaris/build/esm/components/PositionedOverlay/utilities/math.js"],"sourcesContent":["import { Rect } from '../../../utilities/geometry.js';\n\nfunction calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition, fixed, topBarOffset = 0) {\n  const activatorTop = activatorRect.top;\n  const activatorBottom = activatorTop + activatorRect.height;\n  const spaceAbove = activatorRect.top - topBarOffset;\n  const spaceBelow = containerRect.height - activatorRect.top - activatorRect.height;\n  const desiredHeight = overlayRect.height;\n  const verticalMargins = overlayMargins.activator + overlayMargins.container;\n  const minimumSpaceToScroll = overlayMargins.container;\n  const distanceToTopScroll = activatorRect.top - Math.max(scrollableContainerRect.top, 0);\n  const distanceToBottomScroll = containerRect.top + Math.min(containerRect.height, scrollableContainerRect.top + scrollableContainerRect.height) - (activatorRect.top + activatorRect.height);\n  const enoughSpaceFromTopScroll = distanceToTopScroll >= minimumSpaceToScroll;\n  const enoughSpaceFromBottomScroll = distanceToBottomScroll >= minimumSpaceToScroll;\n  const heightIfAbove = Math.min(spaceAbove, desiredHeight);\n  const heightIfBelow = Math.min(spaceBelow, desiredHeight);\n  const heightIfAboveCover = Math.min(spaceAbove + activatorRect.height, desiredHeight);\n  const heightIfBelowCover = Math.min(spaceBelow + activatorRect.height, desiredHeight);\n  const containerRectTop = fixed ? 0 : containerRect.top;\n  const positionIfAbove = {\n    height: heightIfAbove - verticalMargins,\n    top: activatorTop + containerRectTop - heightIfAbove,\n    positioning: 'above'\n  };\n  const positionIfBelow = {\n    height: heightIfBelow - verticalMargins,\n    top: activatorBottom + containerRectTop,\n    positioning: 'below'\n  };\n  const positionIfCoverBelow = {\n    height: heightIfBelowCover - verticalMargins,\n    top: activatorTop + containerRectTop,\n    positioning: 'cover'\n  };\n  const positionIfCoverAbove = {\n    height: heightIfAboveCover - verticalMargins,\n    top: activatorTop + containerRectTop - heightIfAbove + activatorRect.height + verticalMargins,\n    positioning: 'cover'\n  };\n  if (preferredPosition === 'above') {\n    return (enoughSpaceFromTopScroll || distanceToTopScroll >= distanceToBottomScroll && !enoughSpaceFromBottomScroll) && (spaceAbove > desiredHeight || spaceAbove > spaceBelow) ? positionIfAbove : positionIfBelow;\n  }\n  if (preferredPosition === 'below') {\n    return (enoughSpaceFromBottomScroll || distanceToBottomScroll >= distanceToTopScroll && !enoughSpaceFromTopScroll) && (spaceBelow > desiredHeight || spaceBelow > spaceAbove) ? positionIfBelow : positionIfAbove;\n  }\n  if (preferredPosition === 'cover') {\n    return (enoughSpaceFromBottomScroll || distanceToBottomScroll >= distanceToTopScroll && !enoughSpaceFromTopScroll) && (spaceBelow + activatorRect.height > desiredHeight || spaceBelow > spaceAbove) ? positionIfCoverBelow : positionIfCoverAbove;\n  }\n  if (enoughSpaceFromTopScroll && enoughSpaceFromBottomScroll) {\n    return spaceAbove > spaceBelow ? positionIfAbove : positionIfBelow;\n  }\n  return distanceToTopScroll > minimumSpaceToScroll ? positionIfAbove : positionIfBelow;\n}\nfunction calculateHorizontalPosition(activatorRect, overlayRect, containerRect, overlayMargins, preferredAlignment) {\n  const maximum = containerRect.width - overlayRect.width;\n  if (preferredAlignment === 'left') {\n    return Math.min(maximum, Math.max(0, activatorRect.left - overlayMargins.horizontal));\n  } else if (preferredAlignment === 'right') {\n    const activatorRight = containerRect.width - (activatorRect.left + activatorRect.width);\n    return Math.min(maximum, Math.max(0, activatorRight - overlayMargins.horizontal));\n  }\n  return Math.min(maximum, Math.max(0, activatorRect.center.x - overlayRect.width / 2));\n}\nfunction rectIsOutsideOfRect(inner, outer) {\n  const {\n    center\n  } = inner;\n  return center.y < outer.top || center.y > outer.top + outer.height;\n}\nfunction intersectionWithViewport(rect, viewport = windowRect()) {\n  const top = Math.max(rect.top, 0);\n  const left = Math.max(rect.left, 0);\n  const bottom = Math.min(rect.top + rect.height, viewport.height);\n  const right = Math.min(rect.left + rect.width, viewport.width);\n  return new Rect({\n    top,\n    left,\n    height: bottom - top,\n    width: right - left\n  });\n}\nfunction windowRect(node) {\n  const document = node?.ownerDocument || globalThis.document;\n  const window = document.defaultView || globalThis.window;\n  return new Rect({\n    top: window.scrollY,\n    left: window.scrollX,\n    height: window.innerHeight,\n    width: document.body.clientWidth\n  });\n}\n\nexport { calculateHorizontalPosition, calculateVerticalPosition, intersectionWithViewport, rectIsOutsideOfRect, windowRect };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}