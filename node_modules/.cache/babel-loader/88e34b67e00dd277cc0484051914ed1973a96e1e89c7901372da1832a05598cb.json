{"ast":null,"code":"function getVisibleAndHiddenActionsIndices(promotedActions = [], disclosureWidth, actionsWidths, containerWidth) {\n  const sumTabWidths = actionsWidths.reduce((sum, width) => sum + width, 0);\n  const arrayOfPromotedActionsIndices = promotedActions.map((_, index) => {\n    return index;\n  });\n  const visiblePromotedActions = [];\n  const hiddenPromotedActions = [];\n  if (containerWidth > sumTabWidths) {\n    visiblePromotedActions.push(...arrayOfPromotedActionsIndices);\n  } else {\n    let accumulatedWidth = 0;\n    let hasReturned = false;\n    arrayOfPromotedActionsIndices.forEach(currentPromotedActionsIndex => {\n      const currentActionsWidth = actionsWidths[currentPromotedActionsIndex];\n      const notEnoughSpace = accumulatedWidth + currentActionsWidth >= containerWidth - disclosureWidth;\n      if (notEnoughSpace || hasReturned) {\n        hiddenPromotedActions.push(currentPromotedActionsIndex);\n        hasReturned = true;\n        return;\n      }\n      visiblePromotedActions.push(currentPromotedActionsIndex);\n      accumulatedWidth += currentActionsWidth;\n    });\n  }\n  return {\n    visiblePromotedActions,\n    hiddenPromotedActions\n  };\n}\nfunction instanceOfBulkActionListSectionArray(actions) {\n  const validList = actions.filter(action => {\n    return action.items;\n  });\n  return actions.length === validList.length;\n}\nfunction instanceOfBulkActionArray(actions) {\n  const validList = actions.filter(action => {\n    return !action.items;\n  });\n  return actions.length === validList.length;\n}\nfunction instanceOfMenuGroupDescriptor(action) {\n  return 'title' in action && 'actions' in action;\n}\nfunction instanceOfBulkActionListSection(action) {\n  return 'items' in action;\n}\nfunction getActionSections(actions) {\n  if (!actions || actions.length === 0) {\n    return;\n  }\n  if (instanceOfBulkActionListSectionArray(actions)) {\n    return actions;\n  }\n  if (instanceOfBulkActionArray(actions)) {\n    return [{\n      items: actions\n    }];\n  }\n}\nfunction isNewBadgeInBadgeActions(actionSections) {\n  if (!actionSections) return false;\n  for (const action of actionSections) {\n    for (const item of action.items) {\n      if (item.badge?.tone === 'new') return true;\n    }\n  }\n  return false;\n}\nexport { getActionSections, getVisibleAndHiddenActionsIndices, instanceOfBulkActionArray, instanceOfBulkActionListSection, instanceOfBulkActionListSectionArray, instanceOfMenuGroupDescriptor, isNewBadgeInBadgeActions };","map":{"version":3,"names":["getVisibleAndHiddenActionsIndices","promotedActions","disclosureWidth","actionsWidths","containerWidth","sumTabWidths","reduce","sum","width","arrayOfPromotedActionsIndices","map","_","index","visiblePromotedActions","hiddenPromotedActions","push","accumulatedWidth","hasReturned","forEach","currentPromotedActionsIndex","currentActionsWidth","notEnoughSpace","instanceOfBulkActionListSectionArray","actions","validList","filter","action","items","length","instanceOfBulkActionArray","instanceOfMenuGroupDescriptor","instanceOfBulkActionListSection","getActionSections","isNewBadgeInBadgeActions","actionSections","item","badge","tone"],"sources":["/Users/shannondutton/Documents/Code Projects/ProductCreator/node_modules/@shopify/polaris/build/esm/components/BulkActions/utilities.js"],"sourcesContent":["function getVisibleAndHiddenActionsIndices(promotedActions = [], disclosureWidth, actionsWidths, containerWidth) {\n  const sumTabWidths = actionsWidths.reduce((sum, width) => sum + width, 0);\n  const arrayOfPromotedActionsIndices = promotedActions.map((_, index) => {\n    return index;\n  });\n  const visiblePromotedActions = [];\n  const hiddenPromotedActions = [];\n  if (containerWidth > sumTabWidths) {\n    visiblePromotedActions.push(...arrayOfPromotedActionsIndices);\n  } else {\n    let accumulatedWidth = 0;\n    let hasReturned = false;\n    arrayOfPromotedActionsIndices.forEach(currentPromotedActionsIndex => {\n      const currentActionsWidth = actionsWidths[currentPromotedActionsIndex];\n      const notEnoughSpace = accumulatedWidth + currentActionsWidth >= containerWidth - disclosureWidth;\n      if (notEnoughSpace || hasReturned) {\n        hiddenPromotedActions.push(currentPromotedActionsIndex);\n        hasReturned = true;\n        return;\n      }\n      visiblePromotedActions.push(currentPromotedActionsIndex);\n      accumulatedWidth += currentActionsWidth;\n    });\n  }\n  return {\n    visiblePromotedActions,\n    hiddenPromotedActions\n  };\n}\nfunction instanceOfBulkActionListSectionArray(actions) {\n  const validList = actions.filter(action => {\n    return action.items;\n  });\n  return actions.length === validList.length;\n}\nfunction instanceOfBulkActionArray(actions) {\n  const validList = actions.filter(action => {\n    return !action.items;\n  });\n  return actions.length === validList.length;\n}\nfunction instanceOfMenuGroupDescriptor(action) {\n  return 'title' in action && 'actions' in action;\n}\nfunction instanceOfBulkActionListSection(action) {\n  return 'items' in action;\n}\nfunction getActionSections(actions) {\n  if (!actions || actions.length === 0) {\n    return;\n  }\n  if (instanceOfBulkActionListSectionArray(actions)) {\n    return actions;\n  }\n  if (instanceOfBulkActionArray(actions)) {\n    return [{\n      items: actions\n    }];\n  }\n}\nfunction isNewBadgeInBadgeActions(actionSections) {\n  if (!actionSections) return false;\n  for (const action of actionSections) {\n    for (const item of action.items) {\n      if (item.badge?.tone === 'new') return true;\n    }\n  }\n  return false;\n}\n\nexport { getActionSections, getVisibleAndHiddenActionsIndices, instanceOfBulkActionArray, instanceOfBulkActionListSection, instanceOfBulkActionListSectionArray, instanceOfMenuGroupDescriptor, isNewBadgeInBadgeActions };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}