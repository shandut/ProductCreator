{"ast":null,"code":"function debounce(func, waitArg, options) {\n  let lastArgs;\n  let lastThis;\n  let maxWait;\n  let result;\n  let timerId;\n  let lastCallTime;\n  let lastInvokeTime = 0;\n  let leading = false;\n  let maxing = false;\n  let trailing = true;\n\n  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n  const useRAF = !waitArg && waitArg !== 0;\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  const wait = waitArg || 0;\n  if (typeof options === 'object') {\n    leading = Boolean(options.leading);\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : undefined;\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n  }\n  function invokeFunc(time) {\n    const args = lastArgs;\n    const thisArg = lastThis;\n    lastArgs = undefined;\n    lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n  function startTimer(pendingFunc, wait) {\n    if (useRAF) {\n      cancelAnimationFrame(timerId);\n      return requestAnimationFrame(pendingFunc);\n    }\n    return setTimeout(pendingFunc, wait);\n  }\n  function cancelTimer(id) {\n    if (useRAF) {\n      return cancelAnimationFrame(id);\n    }\n    clearTimeout(id);\n  }\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = startTimer(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n  function remainingWait(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n    const timeWaiting = wait - timeSinceLastCall;\n    return maxing && maxWait ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n  }\n  function shouldInvoke(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && maxWait && timeSinceLastInvoke >= maxWait;\n  }\n  function timerExpired() {\n    const time = Date.now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = startTimer(timerExpired, remainingWait(time));\n  }\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    // eslint-disable-next-line no-multi-assign\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n  function cancel() {\n    if (timerId !== undefined) {\n      cancelTimer(timerId);\n    }\n    lastInvokeTime = 0;\n    // eslint-disable-next-line no-multi-assign\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(Date.now());\n  }\n  function pending() {\n    return timerId !== undefined;\n  }\n  function debounced(...args) {\n    const time = Date.now();\n    const isInvoking = shouldInvoke(time);\n    lastArgs = args;\n    // eslint-disable-next-line consistent-this, @typescript-eslint/no-this-alias\n    lastThis = this;\n    lastCallTime = time;\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = startTimer(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = startTimer(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  debounced.pending = pending;\n  return debounced;\n}\nexport { debounce };","map":{"version":3,"names":["debounce","func","waitArg","options","lastArgs","lastThis","maxWait","result","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","useRAF","TypeError","wait","Boolean","Math","max","Number","undefined","invokeFunc","time","args","thisArg","apply","startTimer","pendingFunc","cancelAnimationFrame","requestAnimationFrame","setTimeout","cancelTimer","id","clearTimeout","leadingEdge","timerExpired","remainingWait","timeSinceLastCall","timeSinceLastInvoke","timeWaiting","min","shouldInvoke","Date","now","trailingEdge","cancel","flush","pending","debounced","isInvoking"],"sources":["/Users/shannondutton/Documents/Code Projects/ProductCreator/node_modules/@shopify/polaris/build/esm/utilities/debounce.js"],"sourcesContent":["function debounce(func, waitArg, options) {\n  let lastArgs;\n  let lastThis;\n  let maxWait;\n  let result;\n  let timerId;\n  let lastCallTime;\n  let lastInvokeTime = 0;\n  let leading = false;\n  let maxing = false;\n  let trailing = true;\n\n  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n  const useRAF = !waitArg && waitArg !== 0;\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  const wait = waitArg || 0;\n  if (typeof options === 'object') {\n    leading = Boolean(options.leading);\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : undefined;\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n  }\n  function invokeFunc(time) {\n    const args = lastArgs;\n    const thisArg = lastThis;\n    lastArgs = undefined;\n    lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n  function startTimer(pendingFunc, wait) {\n    if (useRAF) {\n      cancelAnimationFrame(timerId);\n      return requestAnimationFrame(pendingFunc);\n    }\n    return setTimeout(pendingFunc, wait);\n  }\n  function cancelTimer(id) {\n    if (useRAF) {\n      return cancelAnimationFrame(id);\n    }\n    clearTimeout(id);\n  }\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = startTimer(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n  function remainingWait(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n    const timeWaiting = wait - timeSinceLastCall;\n    return maxing && maxWait ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n  }\n  function shouldInvoke(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && maxWait && timeSinceLastInvoke >= maxWait;\n  }\n  function timerExpired() {\n    const time = Date.now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = startTimer(timerExpired, remainingWait(time));\n  }\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    // eslint-disable-next-line no-multi-assign\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n  function cancel() {\n    if (timerId !== undefined) {\n      cancelTimer(timerId);\n    }\n    lastInvokeTime = 0;\n    // eslint-disable-next-line no-multi-assign\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(Date.now());\n  }\n  function pending() {\n    return timerId !== undefined;\n  }\n  function debounced(...args) {\n    const time = Date.now();\n    const isInvoking = shouldInvoke(time);\n    lastArgs = args;\n    // eslint-disable-next-line consistent-this, @typescript-eslint/no-this-alias\n    lastThis = this;\n    lastCallTime = time;\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = startTimer(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = startTimer(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  debounced.pending = pending;\n  return debounced;\n}\n\nexport { debounce };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}